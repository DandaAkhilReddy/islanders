'use strict';

/**
 * Extract key data points from the executive summary markdown generated by the
 * Islanders analytics engine and transform them into structured JSON the Next.js
 * site can consume.
 */

const fs = require('fs');
const path = require('path');

const rootDir = path.resolve(__dirname, '..');
const summaryPath = path.join(
  rootDir,
  'masterprompt_withphoto analysis',
  'executive_summary.md',
);
const outputDir = path.join(
  rootDir,
  'web',
  'src',
  'data',
  'generated',
);
const outputFile = path.join(outputDir, 'executiveSummary.json');

const sanitize = (value) =>
  value
    .replace(/\r\n/g, '\n')
    .replace(/[^\n -~]/g, '')
    .trim();

const readSummary = () => {
  if (!fs.existsSync(summaryPath)) {
    throw new Error(`Executive summary not found at ${summaryPath}`);
  }

  const raw = fs.readFileSync(summaryPath, 'utf8');
  return sanitize(raw);
};

const sectionBetween = (content, startHeading, endHeading) => {
  const startTag = `##  ${startHeading}`;
  const endTag = endHeading ? `##  ${endHeading}` : null;

  const startIdx = content.indexOf(startTag);
  if (startIdx === -1) {
    return '';
  }

  const afterStart = content.slice(startIdx + startTag.length);
  if (!endTag) {
    return afterStart.trim();
  }

  const endIdx = afterStart.indexOf(endTag);
  return (endIdx === -1 ? afterStart : afterStart.slice(0, endIdx)).trim();
};

const parseAchievements = (block) => {
  if (!block) return [];

  const entries = [];
  const lines = block.split('\n');
  let current = null;

  lines.forEach((line) => {
    const trimmed = line.trim();
    if (!trimmed || trimmed === '---') {
      return;
    }

    if (trimmed.startsWith('### ')) {
      if (current) {
        entries.push(current);
      }
      current = {
        title: trimmed.slice(4).trim(),
        bullets: {},
      };
      return;
    }

    if (trimmed.startsWith('- **')) {
      const match = trimmed.match(/- \*\*([^*]+)\*\*\s*(.+)/);
      if (match && current) {
        const key = match[1].replace(/:$/, '').trim();
        const value = match[2].replace(/^:\s*/, '').trim();
        current.bullets[key] = value;
      }
    }
  });

  if (current) {
    entries.push(current);
  }

  return entries;
};

const parsePhotoDistribution = (block) => {
  if (!block) return [];

  const result = [];
  block.split('\n').forEach((line) => {
    const trimmed = line.trim();
    if (!trimmed.startsWith('- **')) return;
    const match = trimmed.match(/- \*\*([^*]+)\*\*\s*(\d+)\s+photos?/i);
    if (match) {
      result.push({
        category: match[1].replace(/:$/, '').trim(),
        count: Number(match[2]),
      });
    }
  });

  return result;
};

const parseKeyPersonnel = (block) => {
  if (!block) return [];

  const lines = block.split('\n');
  const people = [];
  let current = null;

  lines.forEach((line) => {
    const trimmed = line.trim();
    if (!trimmed || trimmed === '---') return;

    if (trimmed.startsWith('### ')) {
      if (current && current.name) {
        people.push(current);
      }
      current = {
        role: trimmed.slice(4).trim(),
        name: '',
        descriptor: '',
        bullets: [],
      };
      return;
    }

    if (trimmed.startsWith('**')) {
      const match = trimmed.match(/\*\*(.+?)\*\*(?:\s*\((.+?)\))?/);
      if (match) {
        if (!current) {
          current = { role: '', bullets: [] };
        }
        current.name = match[1].trim();
        current.descriptor = match[2] ? match[2].trim() : '';
      }
      return;
    }

    if (trimmed.startsWith('- ')) {
      if (!current) {
        current = { role: '', bullets: [] };
      }
      current.bullets.push(trimmed.replace(/^- /, '').trim());
    }
  });

  if (current && current.name) {
    people.push(current);
  }

  return people;
};

const parseSpecialMoments = (block) => {
  if (!block) return [];

  const lines = block.split('\n');
  const moments = [];
  let current = null;

  lines.forEach((line) => {
    const momentMatch = line.match(/^\d+\.\s+\*\*(.+?)\*\*/);
    if (momentMatch) {
      if (current) {
        moments.push(current);
      }
      current = {
        title: momentMatch[1].trim(),
        bullets: [],
      };
      return;
    }

    const bulletMatch = line.match(/^\s*-\s+(.*)/);
    if (bulletMatch && current) {
      current.bullets.push(bulletMatch[1].trim());
    }
  });

  if (current) {
    moments.push(current);
  }

  return moments;
};

const parseTournamentPerformance = (block) => {
  if (!block) return [];

  const entries = [];
  const lines = block.split('\n');
  let current = null;

  lines.forEach((line) => {
    const trimmed = line.trim();
    if (!trimmed || trimmed === '---') return;

    if (trimmed.startsWith('### ')) {
      if (current) {
        entries.push(current);
      }
      current = {
        title: trimmed.slice(4).trim(),
        bullets: [],
      };
      return;
    }

    if (trimmed.startsWith('- ')) {
      if (!current) {
        current = { title: '', bullets: [] };
      }
      current.bullets.push(trimmed.replace(/^- /, '').trim());
    }
  });

  if (current) {
    entries.push(current);
  }

  return entries;
};

const parseMetrics = (content) => {
  const metrics = {};

  const totalMatch = content.match(/\*\*Total Photos Analyzed:\*\*\s*(\d+)/i);
  if (totalMatch) {
    metrics.totalPhotos = Number(totalMatch[1]);
  }

  return metrics;
};

const parseGeneratedDate = (content) => {
  const match = content.match(/\*\*Generated:\*\*\s*([^\n]+)/);
  return match ? match[1].trim() : '';
};

const main = () => {
  const content = readSummary();

  const achievementsBlock = sectionBetween(
    content,
    'Team Achievements',
    'Photo Analysis Summary',
  );
  const photoAnalysisBlock = sectionBetween(
    content,
    'Photo Analysis Summary',
    'Key Personnel',
  );
  const personnelBlock = sectionBetween(
    content,
    'Key Personnel',
    'Special Moments Captured',
  );
  const specialMomentsBlock = sectionBetween(
    content,
    'Special Moments Captured',
    'Tournament Performance',
  );
  const tournamentBlock = sectionBetween(
    content,
    'Tournament Performance',
    'Key Insights',
  );

  const generatedData = {
    generatedAt: parseGeneratedDate(content),
    metrics: parseMetrics(content),
    achievements: parseAchievements(achievementsBlock),
    photoDistribution: parsePhotoDistribution(photoAnalysisBlock),
    keyPersonnel: parseKeyPersonnel(personnelBlock),
    specialMoments: parseSpecialMoments(specialMomentsBlock),
    tournamentPerformance: parseTournamentPerformance(tournamentBlock),
  };

  fs.mkdirSync(outputDir, { recursive: true });
  fs.writeFileSync(outputFile, JSON.stringify(generatedData, null, 2), 'utf8');

  console.log(`Executive summary data written to ${path.relative(rootDir, outputFile)}`);
};

try {
  main();
} catch (error) {
  console.error('[sync-analytics] Failed to generate data:', error.message);
  process.exitCode = 1;
}
